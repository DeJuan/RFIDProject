<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Mercury C API: Reader</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.6.3 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>Reader</h1><table border="0" cellpadding="0" cellspacing="0">
<tr><td colspan="2"><h2>Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_t_m_r___reader.html">TMR_Reader</a></td></tr>
<tr><td colspan="2"><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TMR_Status&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga77b9edd8d948ab1e1d9b95bf546cc43e">TMR_create</a> (<a class="el" href="struct_t_m_r___reader.html">TMR_Reader</a> *reader, const char *deviceUri)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TMR_Status&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga3a75a6998463bfdf20242a3fb9c82427">TMR_create_alloc</a> (<a class="el" href="struct_t_m_r___reader.html">TMR_Reader</a> **readerPointer, const char *deviceUri)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TMR_Status&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#gaf4d6e37515b6206807f60e2d21ca1e52">TMR_connect</a> (struct <a class="el" href="struct_t_m_r___reader.html">TMR_Reader</a> *reader)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TMR_Status&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#gac0d51178a7d1d96ea82c8ea87b1697db">TMR_destroy</a> (<a class="el" href="struct_t_m_r___reader.html">TMR_Reader</a> *reader)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TMR_Status&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#gab477ff41498adaa35ca5cae932ecfc70">TMR_read</a> (<a class="el" href="struct_t_m_r___reader.html">TMR_Reader</a> *reader, uint32_t timeoutMs, int32_t *tagCount)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TMR_Status&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga5925392bbb7aeafc0996144f354a533a">TMR_hasMoreTags</a> (<a class="el" href="struct_t_m_r___reader.html">TMR_Reader</a> *reader)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TMR_Status&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#gabee8bf69ae6010858c5425956308292b">TMR_getNextTag</a> (<a class="el" href="struct_t_m_r___reader.html">TMR_Reader</a> *reader, <a class="el" href="struct_t_m_r___tag_read_data.html">TMR_TagReadData</a> *tagData)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TMR_Status&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga7ada8bde4164982dbee1b641556c004c">TMR_executeTagOp</a> (struct <a class="el" href="struct_t_m_r___reader.html">TMR_Reader</a> *reader, <a class="el" href="struct_t_m_r___tag_op.html">TMR_TagOp</a> *tagop, <a class="el" href="struct_t_m_r___tag_filter.html">TMR_TagFilter</a> *filter, <a class="el" href="struct_t_m_r__uint8_list.html">TMR_uint8List</a> *data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TMR_Status&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#gacc9391a834e069adc7dca9e910f45c06">TMR_readIntoArray</a> (struct <a class="el" href="struct_t_m_r___reader.html">TMR_Reader</a> *reader, uint32_t timeoutMs, int32_t *tagCount, <a class="el" href="struct_t_m_r___tag_read_data.html">TMR_TagReadData</a> *result[])</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TMR_Status&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga2a136073cc2a93bf39ad699d57f9809f">TMR_readTagMemBytes</a> (<a class="el" href="struct_t_m_r___reader.html">TMR_Reader</a> *reader, <a class="el" href="struct_t_m_r___tag_filter.html">TMR_TagFilter</a> *target, uint32_t bank, uint32_t byteAddress, uint16_t byteCount, uint8_t data[])</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TMR_Status&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga3ab6bd275b40ef431a058fdc0e760eba">TMR_readTagMemWords</a> (<a class="el" href="struct_t_m_r___reader.html">TMR_Reader</a> *reader, <a class="el" href="struct_t_m_r___tag_filter.html">TMR_TagFilter</a> *target, uint32_t bank, uint32_t wordAddress, uint16_t wordCount, uint16_t data[])</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TMR_Status&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga10588e2601ace37292564a877c598334">TMR_gpoSet</a> (<a class="el" href="struct_t_m_r___reader.html">TMR_Reader</a> *reader, uint8_t count, const <a class="el" href="struct_t_m_r___gpio_pin.html">TMR_GpioPin</a> state[])</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TMR_Status&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga11ed5acc43ab75e923690e86fcaadc16">TMR_gpiGet</a> (<a class="el" href="struct_t_m_r___reader.html">TMR_Reader</a> *reader, uint8_t *count, <a class="el" href="struct_t_m_r___gpio_pin.html">TMR_GpioPin</a> state[])</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TMR_Status&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga865559def5875922baf2c921e8af822b">TMR_firmwareLoad</a> (<a class="el" href="struct_t_m_r___reader.html">TMR_Reader</a> *reader, void *cookie, <a class="el" href="tmr__types_8h.html#ad5736b555500b6826cb87096b0d6d783">TMR_FirmwareDataProvider</a> provider)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TMR_Status&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#gad8c8030610870c694ff19b9733799dbb">TMR_paramSet</a> (struct <a class="el" href="struct_t_m_r___reader.html">TMR_Reader</a> *reader, <a class="el" href="tmr__params_8h.html#aa2f354f3ef4ea399b19a0c2b626ff692">TMR_Param</a> key, const void *value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TMR_Status&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga799e9d2c2d6b254e689bc53570af8f15">TMR_paramGet</a> (struct <a class="el" href="struct_t_m_r___reader.html">TMR_Reader</a> *reader, <a class="el" href="tmr__params_8h.html#aa2f354f3ef4ea399b19a0c2b626ff692">TMR_Param</a> key, void *value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TMR_Status&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga91e6eaab76b45cfd9662381a381d257b">TMR_reboot</a> (struct <a class="el" href="struct_t_m_r___reader.html">TMR_Reader</a> *reader)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TMR_Status&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#gab0b455295d4984b2fa653f2ebccc263e">TMR_paramList</a> (struct <a class="el" href="struct_t_m_r___reader.html">TMR_Reader</a> *reader, <a class="el" href="tmr__params_8h.html#aa2f354f3ef4ea399b19a0c2b626ff692">TMR_Param</a> *keys, uint32_t *len)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga73f896de4aa8cb256c33a771ab514460">TMR_paramName</a> (<a class="el" href="tmr__params_8h.html#aa2f354f3ef4ea399b19a0c2b626ff692">TMR_Param</a> key)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="tmr__params_8h.html#aa2f354f3ef4ea399b19a0c2b626ff692">TMR_Param</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga837ad11acb819d1427a2d9ecf1cef99a">TMR_paramID</a> (const char *name)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TMR_Status&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#gaf1a35a5a75818801532ec51992123018">TMR_addTransportListener</a> (<a class="el" href="struct_t_m_r___reader.html">TMR_Reader</a> *reader, <a class="el" href="struct_t_m_r___transport_listener_block.html">TMR_TransportListenerBlock</a> *block)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TMR_Status&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga1a07c9bba16ee46f6cc47509bb6d10df">TMR_removeTransportListener</a> (<a class="el" href="struct_t_m_r___reader.html">TMR_Reader</a> *reader, <a class="el" href="struct_t_m_r___transport_listener_block.html">TMR_TransportListenerBlock</a> *block)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TMR_Status&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga18745261e79dccc89a516eaf38cd83f2">TMR_addReadListener</a> (struct <a class="el" href="struct_t_m_r___reader.html">TMR_Reader</a> *reader, <a class="el" href="struct_t_m_r___read_listener_block.html">TMR_ReadListenerBlock</a> *block)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TMR_Status&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga97f95cb1cde2755dc2dd2f1c7243d97b">TMR_addAuthReqListener</a> (struct <a class="el" href="struct_t_m_r___reader.html">TMR_Reader</a> *reader, <a class="el" href="struct_t_m_r___auth_req_listener_block.html">TMR_AuthReqListenerBlock</a> *block)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TMR_Status&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga702b49e0f99507ffe0361b772b161123">TMR_removeReadListener</a> (struct <a class="el" href="struct_t_m_r___reader.html">TMR_Reader</a> *reader, <a class="el" href="struct_t_m_r___read_listener_block.html">TMR_ReadListenerBlock</a> *block)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TMR_Status&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#gada68ed4d7d5dfc41d29eb578d1d8b802">TMR_addReadExceptionListener</a> (struct <a class="el" href="struct_t_m_r___reader.html">TMR_Reader</a> *reader, <a class="el" href="struct_t_m_r___read_exception_listener_block.html">TMR_ReadExceptionListenerBlock</a> *block)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TMR_Status&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga89e04179bc7e159f9cccb070e1c77944">TMR_removeReadExceptionListener</a> (struct <a class="el" href="struct_t_m_r___reader.html">TMR_Reader</a> *reader, <a class="el" href="struct_t_m_r___read_exception_listener_block.html">TMR_ReadExceptionListenerBlock</a> *block)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TMR_Status&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga50ecc20ae31827966119bd2b895925c3">TMR_addStatusListener</a> (struct <a class="el" href="struct_t_m_r___reader.html">TMR_Reader</a> *reader, <a class="el" href="struct_t_m_r___status_listener_block.html">TMR_StatusListenerBlock</a> *block)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TMR_Status&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga138b3773aa362931e911b478fb179d19">TMR_removeStatusListener</a> (struct <a class="el" href="struct_t_m_r___reader.html">TMR_Reader</a> *reader, <a class="el" href="struct_t_m_r___status_listener_block.html">TMR_StatusListenerBlock</a> *block)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TMR_Status&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga46534b9ccf0d47550602d4d66f2d6e16">TMR_addStatsListener</a> (struct <a class="el" href="struct_t_m_r___reader.html">TMR_Reader</a> *reader, <a class="el" href="struct_t_m_r___stats_listener_block.html">TMR_StatsListenerBlock</a> *block)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TMR_Status&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga602f6b819b9c8912764a1e2b88494fc8">TMR_removeStatsListener</a> (struct <a class="el" href="struct_t_m_r___reader.html">TMR_Reader</a> *reader, <a class="el" href="struct_t_m_r___stats_listener_block.html">TMR_StatsListenerBlock</a> *block)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TMR_Status&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#gaad5e5df913bb9150c9d6c1fc12bebe7e">TMR_startReading</a> (struct <a class="el" href="struct_t_m_r___reader.html">TMR_Reader</a> *reader)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TMR_Status&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga82c3f389ceda58871e9c35975390231d">TMR_stopReading</a> (struct <a class="el" href="struct_t_m_r___reader.html">TMR_Reader</a> *reader)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TMR_Status&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#gada58b38b218a125e59e94dacf1e29ed2">TMR_setSerialTransport</a> (char *scheme, TMR_TransportNativeInit nativeInit)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#gaf82e78538b2afb1f21df881b46caf687">TMR_strerr</a> (<a class="el" href="struct_t_m_r___reader.html">TMR_Reader</a> *reader, TMR_Status status)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">TMR_Status&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga50a10c4bfe4f770b138146dc6438b482">TMR_STATS_init</a> (<a class="el" href="struct_t_m_r___reader___stats_values.html">TMR_Reader_StatsValues</a> *stats)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p><a class="el" href="struct_t_m_r___reader.html">TMR_Reader</a> encapsulates a connection to a ThingMagic RFID reader device and provides an interface to perform RFID operations such as reading tags and writing tag IDs.</p>
<p>Reads can be done on demand, with the <a class="el" href="group__reader.html#gab477ff41498adaa35ca5cae932ecfc70">TMR_read()</a> function, or continuously in the background with the <a class="el" href="group__reader.html#gaad5e5df913bb9150c9d6c1fc12bebe7e">TMR_startReading()</a> function. Background reads notify registered listeners of tags that are read.</p>
<p>Operations which take an argument for a tag to operate on may optionally be passed a <code>NULL</code> argument. This lets the reader choose what tag to use, but may not work if multiple tags are present. This use is recommended only when exactly one tag is known to be in range. </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga97f95cb1cde2755dc2dd2f1c7243d97b"></a><!-- doxytag: member="tm_reader.h::TMR_addAuthReqListener" ref="ga97f95cb1cde2755dc2dd2f1c7243d97b" args="(struct TMR_Reader *reader, TMR_AuthReqListenerBlock *block)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TMR_Status TMR_addAuthReqListener </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_t_m_r___reader.html">TMR_Reader</a> *&nbsp;</td>
          <td class="paramname"> <em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_m_r___auth_req_listener_block.html">TMR_AuthReqListenerBlock</a> *&nbsp;</td>
          <td class="paramname"> <em>block</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add a listener to the list of functions that will be called for each background tag read.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>reader</em>&nbsp;</td><td>The reader to operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>block</em>&nbsp;</td><td>A structure containing a pointer to the listener function and a user-supplied cookie value to pass to the function when called. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gada68ed4d7d5dfc41d29eb578d1d8b802"></a><!-- doxytag: member="tm_reader.h::TMR_addReadExceptionListener" ref="gada68ed4d7d5dfc41d29eb578d1d8b802" args="(struct TMR_Reader *reader, TMR_ReadExceptionListenerBlock *block)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TMR_Status TMR_addReadExceptionListener </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_t_m_r___reader.html">TMR_Reader</a> *&nbsp;</td>
          <td class="paramname"> <em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_m_r___read_exception_listener_block.html">TMR_ReadExceptionListenerBlock</a> *&nbsp;</td>
          <td class="paramname"> <em>block</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add a listener to the list of functions that will be called for each error that occurs during background tag reading.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>reader</em>&nbsp;</td><td>The reader to operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>block</em>&nbsp;</td><td>A structure containing a pointer to the listener function and a user-supplied cookie value to pass to the function when called. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga18745261e79dccc89a516eaf38cd83f2"></a><!-- doxytag: member="tm_reader.h::TMR_addReadListener" ref="ga18745261e79dccc89a516eaf38cd83f2" args="(struct TMR_Reader *reader, TMR_ReadListenerBlock *block)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TMR_Status TMR_addReadListener </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_t_m_r___reader.html">TMR_Reader</a> *&nbsp;</td>
          <td class="paramname"> <em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_m_r___read_listener_block.html">TMR_ReadListenerBlock</a> *&nbsp;</td>
          <td class="paramname"> <em>block</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add a listener to the list of functions that will be called for each background tag read.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>reader</em>&nbsp;</td><td>The reader to operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>block</em>&nbsp;</td><td>A structure containing a pointer to the listener function and a user-supplied cookie value to pass to the function when called. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga46534b9ccf0d47550602d4d66f2d6e16"></a><!-- doxytag: member="tm_reader.h::TMR_addStatsListener" ref="ga46534b9ccf0d47550602d4d66f2d6e16" args="(struct TMR_Reader *reader, TMR_StatsListenerBlock *block)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TMR_Status TMR_addStatsListener </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_t_m_r___reader.html">TMR_Reader</a> *&nbsp;</td>
          <td class="paramname"> <em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_m_r___stats_listener_block.html">TMR_StatsListenerBlock</a> *&nbsp;</td>
          <td class="paramname"> <em>block</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add a listener to the list of functions that will be called for each background status response.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>reader</em>&nbsp;</td><td>The reader to operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>block</em>&nbsp;</td><td>A structure containing a pointer to the listener function and a user-supplied cookie value to pass to the function when called. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga50ecc20ae31827966119bd2b895925c3"></a><!-- doxytag: member="tm_reader.h::TMR_addStatusListener" ref="ga50ecc20ae31827966119bd2b895925c3" args="(struct TMR_Reader *reader, TMR_StatusListenerBlock *block)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TMR_Status TMR_addStatusListener </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_t_m_r___reader.html">TMR_Reader</a> *&nbsp;</td>
          <td class="paramname"> <em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_m_r___status_listener_block.html">TMR_StatusListenerBlock</a> *&nbsp;</td>
          <td class="paramname"> <em>block</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add a listener to the list of functions that will be called for each background status response.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>reader</em>&nbsp;</td><td>The reader to operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>block</em>&nbsp;</td><td>A structure containing a pointer to the listener function and a user-supplied cookie value to pass to the function when called. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf1a35a5a75818801532ec51992123018"></a><!-- doxytag: member="tm_reader.h::TMR_addTransportListener" ref="gaf1a35a5a75818801532ec51992123018" args="(TMR_Reader *reader, TMR_TransportListenerBlock *block)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TMR_Status TMR_addTransportListener </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_t_m_r___reader.html">TMR_Reader</a> *&nbsp;</td>
          <td class="paramname"> <em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_m_r___transport_listener_block.html">TMR_TransportListenerBlock</a> *&nbsp;</td>
          <td class="paramname"> <em>block</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Add a listener to the list of functions that will be called for each message sent to or recieved from the reader.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>reader</em>&nbsp;</td><td>The reader to operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>block</em>&nbsp;</td><td>A structure containing a pointer to the listener function and a user-supplied cookie value to pass to the function when called. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf4d6e37515b6206807f60e2d21ca1e52"></a><!-- doxytag: member="tm_reader.h::TMR_connect" ref="gaf4d6e37515b6206807f60e2d21ca1e52" args="(struct TMR_Reader *reader)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TMR_Status TMR_connect </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_t_m_r___reader.html">TMR_Reader</a> *&nbsp;</td>
          <td class="paramname"> <em>reader</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Establishes the connection to the reader at the URI specified in the <a class="el" href="group__reader.html#ga77b9edd8d948ab1e1d9b95bf546cc43e">TMR_create()</a> call. The existence of a reader at the address is verified and the reader is brought into a state appropriate for performing RF operations.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>reader</em>&nbsp;</td><td>The reader to connect</td></tr>
  </table>
  </dd>
</dl>
<dl class="test"><dt><b><a class="el" href="test.html#_test000003">Test:</a></b></dt><dd><p class="startdd">Connecting to existing reader should succeed. </p>
<p class="enddd">Connecting to nonexisting reader should fail. </p>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga77b9edd8d948ab1e1d9b95bf546cc43e"></a><!-- doxytag: member="tm_reader.h::TMR_create" ref="ga77b9edd8d948ab1e1d9b95bf546cc43e" args="(TMR_Reader *reader, const char *deviceUri)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TMR_Status TMR_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_t_m_r___reader.html">TMR_Reader</a> *&nbsp;</td>
          <td class="paramname"> <em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>deviceUri</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The <a class="el" href="struct_t_m_r___reader.html">TMR_Reader</a> struct being initialized should be preallocated by the user. No memory is allocated during the initialization process, and the reader is not contacted at this point.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>reader</em>&nbsp;</td><td>The <a class="el" href="struct_t_m_r___reader.html">TMR_Reader</a> structure to initialize </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>deviceUri</em>&nbsp;</td><td>an identifier for the reader to connect to, with a URI syntax. The scheme can be <code>eapi</code> for the embedded module protocol, <code>rql</code> for the request query language, or <code>tmr</code> to guess. The remainder of the URI identifies the stream that the protocol will be spoken over, either a local host serial port device or a TCP network port. Example URIs are:</p>
<ul>
<li>tmr://192.168.10.8/ - Reader at TCP/IP address 192.168.10.8, RQL assumed</li>
<li>rql://192.168.10.8/ - RQL reader at TCP/IP address 192.168.10.8</li>
<li>tmr:///dev/ttyS1 - reader on serial port /dev/ttyS1, EAPI (serial) assumed</li>
<li>eapi:///COM2 - EAPI (serial) reader on serial port COM2</li>
<li>llrp+eapi://192.168.10.8 - EAPI tunneled over LLRP to a reader at TCP/IP address 192.168.10.8</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="test"><dt><b><a class="el" href="test.html#_test000001">Test:</a></b></dt><dd><p class="startdd">Call with valid URI should not fail. </p>
<p class="enddd">Call with invalid URI should fail. </p>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga3a75a6998463bfdf20242a3fb9c82427"></a><!-- doxytag: member="tm_reader.h::TMR_create_alloc" ref="ga3a75a6998463bfdf20242a3fb9c82427" args="(TMR_Reader **readerPointer, const char *deviceUri)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TMR_Status TMR_create_alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_t_m_r___reader.html">TMR_Reader</a> **&nbsp;</td>
          <td class="paramname"> <em>readerPointer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>deviceUri</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function is a version of <a class="el" href="group__reader.html#ga77b9edd8d948ab1e1d9b95bf546cc43e">TMR_create()</a> that dynamically allocates the <a class="el" href="struct_t_m_r___reader.html">TMR_Reader</a> structure and stores the pointer in *reader.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>readerPointer</em>&nbsp;</td><td>Pointer to the TMR_Reader* in which to place the pointer to the newly allocated reader structure. @ </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>deviceUri</em>&nbsp;</td><td>As described in <a class="el" href="group__reader.html#ga77b9edd8d948ab1e1d9b95bf546cc43e">TMR_create()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="test"><dt><b><a class="el" href="test.html#_test000002">Test:</a></b></dt><dd><p class="startdd">Call with valid URI should not fail. </p>
<p>Call with invalid URI should fail. </p>
<p class="enddd">Multiple calls with different URIs should return distinct objects. </p>
</dd></dl>

</div>
</div>
<a class="anchor" id="gac0d51178a7d1d96ea82c8ea87b1697db"></a><!-- doxytag: member="tm_reader.h::TMR_destroy" ref="gac0d51178a7d1d96ea82c8ea87b1697db" args="(TMR_Reader *reader)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TMR_Status TMR_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_t_m_r___reader.html">TMR_Reader</a> *&nbsp;</td>
          <td class="paramname"> <em>reader</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Closes the connection to the reader and releases any resources that have been consumed by the reader structure.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>reader</em>&nbsp;</td><td>The reader to shut down.</td></tr>
  </table>
  </dd>
</dl>
<dl class="test"><dt><b><a class="el" href="test.html#_test000004">Test:</a></b></dt><dd><p class="startdd">Destroying existing connected reader should succed. </p>
<p>Destroying existing unconnected reader should succeed. </p>
<p>Destroying already-destroyed reader should fail. </p>
<p class="enddd">Destroying reader allocated by <a class="el" href="group__reader.html#ga3a75a6998463bfdf20242a3fb9c82427">TMR_create_alloc()</a> should free the allocated memory. </p>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga7ada8bde4164982dbee1b641556c004c"></a><!-- doxytag: member="tm_reader.h::TMR_executeTagOp" ref="ga7ada8bde4164982dbee1b641556c004c" args="(struct TMR_Reader *reader, TMR_TagOp *tagop, TMR_TagFilter *filter, TMR_uint8List *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TMR_Status TMR_executeTagOp </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_t_m_r___reader.html">TMR_Reader</a> *&nbsp;</td>
          <td class="paramname"> <em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_m_r___tag_op.html">TMR_TagOp</a> *&nbsp;</td>
          <td class="paramname"> <em>tagop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_m_r___tag_filter.html">TMR_TagFilter</a> *&nbsp;</td>
          <td class="paramname"> <em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_m_r__uint8_list.html">TMR_uint8List</a> *&nbsp;</td>
          <td class="paramname"> <em>data</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This method provides the direct execution of TagOp commands Reader operates on the first tag found, with applicable tag filtering Reader stops and the call returns immediately after finding one tag and operating on it, unless the command timeout expires first The operation is performed on the antenna specified in /reader/tagop/antenna parameter /reader/tagop/protocol specifies the protocol to be used</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>reader</em>&nbsp;</td><td>The reader being operated on </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tagop</em>&nbsp;</td><td>Pointer to the <a class="el" href="struct_t_m_r___tag_op.html">TMR_TagOp</a> which needs to be executed </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>filter</em>&nbsp;</td><td>Tag Filter to be used </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>data</em>&nbsp;</td><td>Data returned as a result of tag operation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga865559def5875922baf2c921e8af822b"></a><!-- doxytag: member="tm_reader.h::TMR_firmwareLoad" ref="ga865559def5875922baf2c921e8af822b" args="(TMR_Reader *reader, void *cookie, TMR_FirmwareDataProvider provider)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TMR_Status TMR_firmwareLoad </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_t_m_r___reader.html">TMR_Reader</a> *&nbsp;</td>
          <td class="paramname"> <em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>cookie</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tmr__types_8h.html#ad5736b555500b6826cb87096b0d6d783">TMR_FirmwareDataProvider</a>&nbsp;</td>
          <td class="paramname"> <em>provider</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The <a class="el" href="group__reader.html#ga865559def5875922baf2c921e8af822b">TMR_firmwareLoad()</a> method attempts to install firmware on the reader, then restart and reinitialize.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>reader</em>&nbsp;</td><td>The reader to operate on </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cookie</em>&nbsp;</td><td>Value to pass to the callback function. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>provider</em>&nbsp;</td><td>Callback function to provide firmware data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gabee8bf69ae6010858c5425956308292b"></a><!-- doxytag: member="tm_reader.h::TMR_getNextTag" ref="gabee8bf69ae6010858c5425956308292b" args="(TMR_Reader *reader, TMR_TagReadData *tagData)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TMR_Status TMR_getNextTag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_t_m_r___reader.html">TMR_Reader</a> *&nbsp;</td>
          <td class="paramname"> <em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_m_r___tag_read_data.html">TMR_TagReadData</a> *&nbsp;</td>
          <td class="paramname"> <em>tagData</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fetches the next tag from the last <a class="el" href="group__reader.html#gab477ff41498adaa35ca5cae932ecfc70">TMR_read()</a> operation.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>reader</em>&nbsp;</td><td>The reader being operated on </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>tagData</em>&nbsp;</td><td>The <a class="el" href="struct_t_m_r___tag_read_data.html">TMR_TagReadData</a> structure to fill.</td></tr>
  </table>
  </dd>
</dl>
<dl class="test"><dt><b><a class="el" href="test.html#_test000007">Test:</a></b></dt><dd><p class="startdd">Call should fail before a read() call. </p>
<p>Call should fail after a read() call that set *tagCount to zero. </p>
<p>Call should fill in a tag after a read() call that set *tagCount to a nonzero value. </p>
<p class="enddd">Call should succeed exactly as many times as specified by *tagCount. </p>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga11ed5acc43ab75e923690e86fcaadc16"></a><!-- doxytag: member="tm_reader.h::TMR_gpiGet" ref="ga11ed5acc43ab75e923690e86fcaadc16" args="(TMR_Reader *reader, uint8_t *count, TMR_GpioPin state[])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TMR_Status TMR_gpiGet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_t_m_r___reader.html">TMR_Reader</a> *&nbsp;</td>
          <td class="paramname"> <em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&nbsp;</td>
          <td class="paramname"> <em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_m_r___gpio_pin.html">TMR_GpioPin</a>&nbsp;</td>
          <td class="paramname"> <em>state</em>[]</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the state of all GPI pins.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>reader</em>&nbsp;</td><td>The reader to operate on. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>count</em>&nbsp;</td><td>Pointer to the allocated length of the state array. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>count</em>&nbsp;</td><td>Pointer to the number of entries in the state array. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>state</em>&nbsp;</td><td>Array of reader pins and the state to set them to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga10588e2601ace37292564a877c598334"></a><!-- doxytag: member="tm_reader.h::TMR_gpoSet" ref="ga10588e2601ace37292564a877c598334" args="(TMR_Reader *reader, uint8_t count, const TMR_GpioPin state[])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TMR_Status TMR_gpoSet </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_t_m_r___reader.html">TMR_Reader</a> *&nbsp;</td>
          <td class="paramname"> <em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_t_m_r___gpio_pin.html">TMR_GpioPin</a>&nbsp;</td>
          <td class="paramname"> <em>state</em>[]</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the state of some GPO pins.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>reader</em>&nbsp;</td><td>The reader to operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>The length of the state array. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>state</em>&nbsp;</td><td>Array of reader pins and the state to set them to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga5925392bbb7aeafc0996144f354a533a"></a><!-- doxytag: member="tm_reader.h::TMR_hasMoreTags" ref="ga5925392bbb7aeafc0996144f354a533a" args="(TMR_Reader *reader)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TMR_Status TMR_hasMoreTags </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_t_m_r___reader.html">TMR_Reader</a> *&nbsp;</td>
          <td class="paramname"> <em>reader</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<dl><dt><b>Return values:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>TMR_SUCCESS</em>&nbsp;</td><td>if there are more tags to be retrieved from the most recent <a class="el" href="group__reader.html#gab477ff41498adaa35ca5cae932ecfc70">TMR_read()</a> operation. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>TMR_ERROR_NO_TAGS</em>&nbsp;</td><td>if no more tags are available for retrieval. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Other</em>&nbsp;</td><td>TMR_ERRORs when appropriate.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>reader</em>&nbsp;</td><td>The reader being operated on</td></tr>
  </table>
  </dd>
</dl>
<dl class="test"><dt><b><a class="el" href="test.html#_test000006">Test:</a></b></dt><dd><p class="startdd">Call should return false before a read() call. </p>
<p>Call should return false after a read() call that set *tagCount to zero. </p>
<p>Call should return true after a read() call that set *tagCount to a nonzero value. </p>
<p class="enddd">Call should return true through exactly as many getNextTag() calls as specified by *tagCount. </p>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga799e9d2c2d6b254e689bc53570af8f15"></a><!-- doxytag: member="tm_reader.h::TMR_paramGet" ref="ga799e9d2c2d6b254e689bc53570af8f15" args="(struct TMR_Reader *reader, TMR_Param key, void *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TMR_Status TMR_paramGet </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_t_m_r___reader.html">TMR_Reader</a> *&nbsp;</td>
          <td class="paramname"> <em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tmr__params_8h.html#aa2f354f3ef4ea399b19a0c2b626ff692">TMR_Param</a>&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get the value of a reader parameter.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>reader</em>&nbsp;</td><td>The reader to operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>The string identifying the parameter.</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>value</em>&nbsp;</td><td>Pointer to the parameter value. For list types (including <a class="el" href="struct_t_m_r___string.html">TMR_String</a>), the caller must allocate the pointed-to space and set the size of the allocated space in the max field, and the function will write into that space and set the actual length of the data. If the list or string is larger than will fit in the pointed-to space, the length will be larger than the allocated space - be careful iterating over the results if there is a chance of not passing in a large enough structure.</td></tr>
  </table>
  </dd>
</dl>
<dl class="test"><dt><b><a class="el" href="test.html#_test000011">Test:</a></b></dt><dd><p class="startdd">Call should fail if key is an invalid parameter name. </p>
<p>Call should fail if key is valid but unsupported by connected reader. </p>
<p class="enddd">Call should succeed if key matches parameter name, independent of case. </p>
</dd></dl>

</div>
</div>
<a class="anchor" id="ga837ad11acb819d1427a2d9ecf1cef99a"></a><!-- doxytag: member="tm_reader.h::TMR_paramID" ref="ga837ad11acb819d1427a2d9ecf1cef99a" args="(const char *name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="tmr__params_8h.html#aa2f354f3ef4ea399b19a0c2b626ff692">TMR_Param</a> TMR_paramID </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>name</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the TMR_Param ID corresponding to a string name. Only present if TMR_ENABLE_PARAM_STRINGS is set.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>name</em>&nbsp;</td><td>the parameter </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The TMR_Param value of the name, or TMR_PARAM_NONE if no such parameter exists. </dd></dl>

</div>
</div>
<a class="anchor" id="gab0b455295d4984b2fa653f2ebccc263e"></a><!-- doxytag: member="tm_reader.h::TMR_paramList" ref="gab0b455295d4984b2fa653f2ebccc263e" args="(struct TMR_Reader *reader, TMR_Param *keys, uint32_t *len)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TMR_Status TMR_paramList </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_t_m_r___reader.html">TMR_Reader</a> *&nbsp;</td>
          <td class="paramname"> <em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tmr__params_8h.html#aa2f354f3ef4ea399b19a0c2b626ff692">TMR_Param</a> *&nbsp;</td>
          <td class="paramname"> <em>keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&nbsp;</td>
          <td class="paramname"> <em>len</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get a list of the parameters available</p>
<p>Supported Parameters: </p>
<ul>
<li>/reader/antenna/checkPort </li>
<li>/reader/antenna/connectedPortList </li>
<li>/reader/antenna/portList </li>
<li>/reader/antenna/portSwitchGpos </li>
<li>/reader/antenna/returnLoss </li>
<li>/reader/antenna/settlingTimeList </li>
<li>/reader/antenna/txRxMap </li>
<li>/reader/asyncofftime </li>
<li>/reader/baudRate </li>
<li>/reader/commandTimeout </li>
<li>/reader/currentTime </li>
<li>/reader/description </li>
<li>/reader/extendedEpc </li>
<li>/reader/gen2/BLF </li>
<li>/reader/gen2/accessPassword </li>
<li>/reader/gen2/bap </li>
<li>/reader/gen2/q </li>
<li>/reader/gen2/session </li>
<li>/reader/gen2/tagEncoding </li>
<li>/reader/gen2/target </li>
<li>/reader/gen2/tari </li>
<li>/reader/gen2/writeEarlyExit </li>
<li>/reader/gen2/writeMode </li>
<li>/reader/gen2/writeReplyTimeout </li>
<li>/reader/gpio/inputList </li>
<li>/reader/gpio/outputList </li>
<li>/reader/hostname </li>
<li>/reader/iso180006b/BLF </li>
<li>/reader/iso180006b/delimiter </li>
<li>/reader/iso180006b/modulationDepth </li>
<li>/reader/licenseKey </li>
<li>/reader/powerMode </li>
<li>/reader/probeBaudRates </li>
<li>/reader/radio/enablePowerSave </li>
<li>/reader/radio/enableSJC </li>
<li>/reader/radio/portReadPowerList </li>
<li>/reader/radio/portWritePowerList </li>
<li>/reader/radio/powerMax </li>
<li>/reader/radio/powerMin </li>
<li>/reader/radio/readPower </li>
<li>/reader/radio/temperature </li>
<li>/reader/radio/writePower </li>
<li>/reader/read/asyncOffTime </li>
<li>/reader/read/asyncOnTime </li>
<li>/reader/read/plan </li>
<li>/reader/region/hopTable </li>
<li>/reader/region/hopTime </li>
<li>/reader/region/id </li>
<li>/reader/region/lbt/enable </li>
<li>/reader/region/supportedRegions </li>
<li>/reader/statistics </li>
<li>/reader/stats </li>
<li>/reader/status/antennaEnable </li>
<li>/reader/status/frequencyEnable </li>
<li>/reader/status/temperatureEnable </li>
<li>/reader/tagReadData/enableReadFilter </li>
<li>/reader/tagReadData/readFilterTimeout </li>
<li>/reader/tagReadData/recordHighestRssi </li>
<li>/reader/tagReadData/reportRssiInDbm </li>
<li>/reader/tagReadData/tagopFailures </li>
<li>/reader/tagReadData/tagopSuccesses </li>
<li>/reader/tagReadData/uniqueByAntenna </li>
<li>/reader/tagReadData/uniqueByData </li>
<li>/reader/tagReadData/uniqueByProtocol </li>
<li>/reader/tagop/antenna </li>
<li>/reader/tagop/protocol </li>
<li>/reader/transportTimeout </li>
<li>/reader/uri </li>
<li>/reader/userConfig </li>
<li>/reader/userMode </li>
<li>/reader/version/hardware </li>
<li>/reader/version/model </li>
<li>/reader/version/productGroup </li>
<li>/reader/version/productGroupID </li>
<li>/reader/version/productID </li>
<li>/reader/version/serial </li>
<li>/reader/version/software </li>
<li>/reader/version/supportedProtocols</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>reader</em>&nbsp;</td><td>The reader to operate on. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>keys</em>&nbsp;</td><td>Pointer to the list of parameters. The caller must allocate space for the parameters. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>len</em>&nbsp;</td><td>Pointer to the allocated length of the space pointed to by keys. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>len</em>&nbsp;</td><td>Pointer to the number of parameters supported by the reader, which may be larger or smaller than the provided array. If it is larger than the provided array, the list is truncated.</td></tr>
  </table>
  </dd>
</dl>
<p>Get a list of the parameters available  pointer of reader object  pointer of TMR_Param  pointer to uint32_t </p>

</div>
</div>
<a class="anchor" id="ga73f896de4aa8cb256c33a771ab514460"></a><!-- doxytag: member="tm_reader.h::TMR_paramName" ref="ga73f896de4aa8cb256c33a771ab514460" args="(TMR_Param key)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* TMR_paramName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tmr__params_8h.html#aa2f354f3ef4ea399b19a0c2b626ff692">TMR_Param</a>&nbsp;</td>
          <td class="paramname"> <em>key</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the string name corresponding to a TMR_Param value. Only present if TMR_ENABLE_PARAM_STRINGS is set.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>The parameter ID. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The corresponding string name. </dd></dl>

</div>
</div>
<a class="anchor" id="gad8c8030610870c694ff19b9733799dbb"></a><!-- doxytag: member="tm_reader.h::TMR_paramSet" ref="gad8c8030610870c694ff19b9733799dbb" args="(struct TMR_Reader *reader, TMR_Param key, const void *value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TMR_Status TMR_paramSet </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_t_m_r___reader.html">TMR_Reader</a> *&nbsp;</td>
          <td class="paramname"> <em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tmr__params_8h.html#aa2f354f3ef4ea399b19a0c2b626ff692">TMR_Param</a>&nbsp;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Set the value of a reader parameter.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>reader</em>&nbsp;</td><td>The reader to operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>key</em>&nbsp;</td><td>The string identifying the parameter. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>value</em>&nbsp;</td><td>The new value to use for the parameter. The caller may not alter the value after passing it to this function.</td></tr>
  </table>
  </dd>
</dl>
<dl class="test"><dt><b><a class="el" href="test.html#_test000010">Test:</a></b></dt><dd><p class="startdd">Call should fail if key is an invalid parameter name. </p>
<p>Call should fail if key is valid but unsupported by connected reader. </p>
<p class="enddd">Call should succeed if key matches parameter name, independent of case. </p>
</dd></dl>

</div>
</div>
<a class="anchor" id="gab477ff41498adaa35ca5cae932ecfc70"></a><!-- doxytag: member="tm_reader.h::TMR_read" ref="gab477ff41498adaa35ca5cae932ecfc70" args="(TMR_Reader *reader, uint32_t timeoutMs, int32_t *tagCount)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TMR_Status TMR_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_t_m_r___reader.html">TMR_Reader</a> *&nbsp;</td>
          <td class="paramname"> <em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>timeoutMs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&nbsp;</td>
          <td class="paramname"> <em>tagCount</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Search for tags for a fixed duration. Once this returns, the tags are retrieved by calling <a class="el" href="group__reader.html#gabee8bf69ae6010858c5425956308292b">TMR_getNextTag()</a> until <a class="el" href="group__reader.html#ga5925392bbb7aeafc0996144f354a533a">TMR_hasMoreTags()</a> returns false.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>reader</em>&nbsp;</td><td>The reader being operated on </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeoutMs</em>&nbsp;</td><td>The number of milliseconds to search for tags </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>tagCount</em>&nbsp;</td><td>The number of tags read, or -1 if the number is unknown. If NULL, no value will be stored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="test"><dt><b><a class="el" href="test.html#_test000005">Test:</a></b></dt><dd><p class="startdd">Call should fail if reader is not connected. </p>
<p class="enddd">If call is successful as per TMR_Error, *tagCount should be modified and contain a positive value. </p>
</dd></dl>

</div>
</div>
<a class="anchor" id="gacc9391a834e069adc7dca9e910f45c06"></a><!-- doxytag: member="tm_reader.h::TMR_readIntoArray" ref="gacc9391a834e069adc7dca9e910f45c06" args="(struct TMR_Reader *reader, uint32_t timeoutMs, int32_t *tagCount, TMR_TagReadData *result[])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TMR_Status TMR_readIntoArray </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_t_m_r___reader.html">TMR_Reader</a> *&nbsp;</td>
          <td class="paramname"> <em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>timeoutMs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&nbsp;</td>
          <td class="paramname"> <em>tagCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_m_r___tag_read_data.html">TMR_TagReadData</a> *&nbsp;</td>
          <td class="paramname"> <em>result</em>[]</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Wrapper routine that searches for tags, allocates space for the results, and returns the results in a single array.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>reader</em>&nbsp;</td><td>The reader being operated on </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>timeoutMs</em>&nbsp;</td><td>The number of milliseconds to search for tags </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>tagCount</em>&nbsp;</td><td>The number of tags found and the size of the allocated array. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>result</em>&nbsp;</td><td>The array of tag read data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="test"><dt><b><a class="el" href="test.html#_test000008">Test:</a></b></dt><dd><p class="startdd">Call should fail if reader is not connected. </p>
<p class="enddd">If call is successful as per TMR_Error, *tagCount should be modified and contain a positive value, and *result should be modified and contain the corresponding number of tag read values.</p>
</dd></dl>
<p>Out param "result" should be freed after using it. </p>

</div>
</div>
<a class="anchor" id="ga2a136073cc2a93bf39ad699d57f9809f"></a><!-- doxytag: member="tm_reader.h::TMR_readTagMemBytes" ref="ga2a136073cc2a93bf39ad699d57f9809f" args="(TMR_Reader *reader, TMR_TagFilter *target, uint32_t bank, uint32_t byteAddress, uint16_t byteCount, uint8_t data[])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TMR_Status TMR_readTagMemBytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_t_m_r___reader.html">TMR_Reader</a> *&nbsp;</td>
          <td class="paramname"> <em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_m_r___tag_filter.html">TMR_TagFilter</a> *&nbsp;</td>
          <td class="paramname"> <em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>bank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>byteAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>byteCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>data</em>[]</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read 8-bit bytes from the memory bank of a tag.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>reader</em>&nbsp;</td><td>The reader being operated on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>target</em>&nbsp;</td><td>The tag to read from, or <code>NULL</code>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bank</em>&nbsp;</td><td>The tag memory bank to read from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>byteAddress</em>&nbsp;</td><td>The byte address to start reading at. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>byteCount</em>&nbsp;</td><td>The number of bytes to read </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>data</em>&nbsp;</td><td>The read data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga3ab6bd275b40ef431a058fdc0e760eba"></a><!-- doxytag: member="tm_reader.h::TMR_readTagMemWords" ref="ga3ab6bd275b40ef431a058fdc0e760eba" args="(TMR_Reader *reader, TMR_TagFilter *target, uint32_t bank, uint32_t wordAddress, uint16_t wordCount, uint16_t data[])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TMR_Status TMR_readTagMemWords </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_t_m_r___reader.html">TMR_Reader</a> *&nbsp;</td>
          <td class="paramname"> <em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_m_r___tag_filter.html">TMR_TagFilter</a> *&nbsp;</td>
          <td class="paramname"> <em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>bank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>wordAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>wordCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>data</em>[]</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Read 16-bit words from the memory bank of a tag.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>reader</em>&nbsp;</td><td>The reader being operated on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>target</em>&nbsp;</td><td>The tag to read from, or <code>NULL</code>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bank</em>&nbsp;</td><td>The tag memory bank to read from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>wordAddress</em>&nbsp;</td><td>The word address to start reading at. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>wordCount</em>&nbsp;</td><td>The number of words to read </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>data</em>&nbsp;</td><td>The read data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga91e6eaab76b45cfd9662381a381d257b"></a><!-- doxytag: member="tm_reader.h::TMR_reboot" ref="ga91e6eaab76b45cfd9662381a381d257b" args="(struct TMR_Reader *reader)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TMR_Status TMR_reboot </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_t_m_r___reader.html">TMR_Reader</a> *&nbsp;</td>
          <td class="paramname"> <em>reader</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reboot the reader</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>reader</em>&nbsp;</td><td>The reader to operate on. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga89e04179bc7e159f9cccb070e1c77944"></a><!-- doxytag: member="tm_reader.h::TMR_removeReadExceptionListener" ref="ga89e04179bc7e159f9cccb070e1c77944" args="(struct TMR_Reader *reader, TMR_ReadExceptionListenerBlock *block)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TMR_Status TMR_removeReadExceptionListener </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_t_m_r___reader.html">TMR_Reader</a> *&nbsp;</td>
          <td class="paramname"> <em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_m_r___read_exception_listener_block.html">TMR_ReadExceptionListenerBlock</a> *&nbsp;</td>
          <td class="paramname"> <em>block</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove a listener from the list of functions that will be called for each error that occurs during background tag reading.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>reader</em>&nbsp;</td><td>The reader to operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>block</em>&nbsp;</td><td>A structure containing a pointer to the listener function and a user-supplied cookie value to pass to the function when called. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga702b49e0f99507ffe0361b772b161123"></a><!-- doxytag: member="tm_reader.h::TMR_removeReadListener" ref="ga702b49e0f99507ffe0361b772b161123" args="(struct TMR_Reader *reader, TMR_ReadListenerBlock *block)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TMR_Status TMR_removeReadListener </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_t_m_r___reader.html">TMR_Reader</a> *&nbsp;</td>
          <td class="paramname"> <em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_m_r___read_listener_block.html">TMR_ReadListenerBlock</a> *&nbsp;</td>
          <td class="paramname"> <em>block</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove a listener from the list of functions that will be called for each background tag read.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>reader</em>&nbsp;</td><td>The reader to operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>block</em>&nbsp;</td><td>A structure containing a pointer to the listener function and a user-supplied cookie value to pass to the function when called. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga602f6b819b9c8912764a1e2b88494fc8"></a><!-- doxytag: member="tm_reader.h::TMR_removeStatsListener" ref="ga602f6b819b9c8912764a1e2b88494fc8" args="(struct TMR_Reader *reader, TMR_StatsListenerBlock *block)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TMR_Status TMR_removeStatsListener </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_t_m_r___reader.html">TMR_Reader</a> *&nbsp;</td>
          <td class="paramname"> <em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_m_r___stats_listener_block.html">TMR_StatsListenerBlock</a> *&nbsp;</td>
          <td class="paramname"> <em>block</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove a listener from the list of functions that will be called for each background status response.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>reader</em>&nbsp;</td><td>The reader to operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>block</em>&nbsp;</td><td>A structure containing a pointer to the listener function and a user-supplied cookie value to pass to the function when called. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga138b3773aa362931e911b478fb179d19"></a><!-- doxytag: member="tm_reader.h::TMR_removeStatusListener" ref="ga138b3773aa362931e911b478fb179d19" args="(struct TMR_Reader *reader, TMR_StatusListenerBlock *block)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TMR_Status TMR_removeStatusListener </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_t_m_r___reader.html">TMR_Reader</a> *&nbsp;</td>
          <td class="paramname"> <em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_m_r___status_listener_block.html">TMR_StatusListenerBlock</a> *&nbsp;</td>
          <td class="paramname"> <em>block</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove a listener from the list of functions that will be called for each background status response.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>reader</em>&nbsp;</td><td>The reader to operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>block</em>&nbsp;</td><td>A structure containing a pointer to the listener function and a user-supplied cookie value to pass to the function when called. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1a07c9bba16ee46f6cc47509bb6d10df"></a><!-- doxytag: member="tm_reader.h::TMR_removeTransportListener" ref="ga1a07c9bba16ee46f6cc47509bb6d10df" args="(TMR_Reader *reader, TMR_TransportListenerBlock *block)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TMR_Status TMR_removeTransportListener </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_t_m_r___reader.html">TMR_Reader</a> *&nbsp;</td>
          <td class="paramname"> <em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_m_r___transport_listener_block.html">TMR_TransportListenerBlock</a> *&nbsp;</td>
          <td class="paramname"> <em>block</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Remove a listener from the list of functions that will be called for each message sent to or recieved from the reader.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>reader</em>&nbsp;</td><td>The reader to operate on. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>block</em>&nbsp;</td><td>A structure containing a pointer to the listener function and a user-supplied cookie value to pass to the function when called. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gada58b38b218a125e59e94dacf1e29ed2"></a><!-- doxytag: member="tm_reader.h::TMR_setSerialTransport" ref="gada58b38b218a125e59e94dacf1e29ed2" args="(char *scheme, TMR_TransportNativeInit nativeInit)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TMR_Status TMR_setSerialTransport </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>scheme</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TMR_TransportNativeInit&nbsp;</td>
          <td class="paramname"> <em>nativeInit</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Stores the transport init function againest the provided scheme.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>scheme</em>&nbsp;</td><td>the transport schme name. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>nativeInit</em>&nbsp;</td><td>reference to the init function. </td></tr>
  </table>
  </dd>
</dl>

<p><p>Currently set serial transport is only supported for serial readers only.</p>
</p>

</div>
</div>
<a class="anchor" id="gaad5e5df913bb9150c9d6c1fc12bebe7e"></a><!-- doxytag: member="tm_reader.h::TMR_startReading" ref="gaad5e5df913bb9150c9d6c1fc12bebe7e" args="(struct TMR_Reader *reader)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TMR_Status TMR_startReading </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_t_m_r___reader.html">TMR_Reader</a> *&nbsp;</td>
          <td class="paramname"> <em>reader</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Start reading tags in the background. The tags found will be passed to the registered read listeners, and any errors that occur during reading will be passed to the registered exception listeners. Reading will continue until stopReading() is called. The read listeners will be called from a background thread.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>reader</em>&nbsp;</td><td>The reader to operate on. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga50a10c4bfe4f770b138146dc6438b482"></a><!-- doxytag: member="tm_reader.h::TMR_STATS_init" ref="ga50a10c4bfe4f770b138146dc6438b482" args="(TMR_Reader_StatsValues *stats)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TMR_Status TMR_STATS_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_t_m_r___reader___stats_values.html">TMR_Reader_StatsValues</a> *&nbsp;</td>
          <td class="paramname"> <em>stats</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This funcution will initialize the TMR_StatValues structure with the default values</p>
<p>Initialize a TMR_StatValues structure with the default vales</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>stats</em>&nbsp;</td><td>Pointer to the TMR_StatValues structure to initialize. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga82c3f389ceda58871e9c35975390231d"></a><!-- doxytag: member="tm_reader.h::TMR_stopReading" ref="ga82c3f389ceda58871e9c35975390231d" args="(struct TMR_Reader *reader)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TMR_Status TMR_stopReading </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="struct_t_m_r___reader.html">TMR_Reader</a> *&nbsp;</td>
          <td class="paramname"> <em>reader</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Stop reading tags in the background. This function will wait until the reader has stopped.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>reader</em>&nbsp;</td><td>The reader to operate on. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gaf82e78538b2afb1f21df881b46caf687"></a><!-- doxytag: member="tm_reader.h::TMR_strerr" ref="gaf82e78538b2afb1f21df881b46caf687" args="(TMR_Reader *reader, TMR_Status status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* TMR_strerr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_t_m_r___reader.html">TMR_Reader</a> *&nbsp;</td>
          <td class="paramname"> <em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TMR_Status&nbsp;</td>
          <td class="paramname"> <em>status</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function will convert the error codes into proper error messages.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>reader</em>&nbsp;</td><td>The reader which resulted in error </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>status</em>&nbsp;</td><td>The status code which is to be converted </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div>
<hr class="footer"/><address style="text-align: right;"><small>Generated on Mon Jun 23 07:11:10 2014 for Mercury C API by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.6.3 </small></address>
</body>
</html>
